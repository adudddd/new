<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Coastal Defense Retro</title>
  <!-- Retro pixel font -->
  <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
  <style>
    /* ... (Your CSS styles, no changes needed here) ... */
  </style>
</head>
<body>
  <!-- ... (Your HTML structure, no changes needed here) ... -->
  </div>

  <script>
    // ===== Global Variables & Setup =====
    const gameContainer = document.getElementById('gameContainer');
    const startScreen = document.getElementById('startScreen');
    const startButton = document.getElementById('startButton');
    const pauseMenu = document.getElementById('pauseMenu');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const restartButton = document.getElementById('restartButton');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const healthSegments = document.querySelectorAll('.healthSegment');
    const miniMap = document.getElementById('miniMap');
    const playerShip = document.querySelector('.playerShip');

    // Initialize player's left position
    let playerShipX = parseInt(getComputedStyle(playerShip).left) || 375;
    
    let score = 0;
    let playerHealth = 100;
    let enemies = [];
    let bullets = [];
    let gameInterval;
    let gamePaused = false;
     let gameRunning = false;   // Crucial: Track if the game is actually running


    // ===== HUD & Feedback Functions ===== (No changes here) ...

    // ===== Dynamic Background Animation ===== (No changes here) ...

    // ===== Enemy Creation & Movement =====
   function createEnemy(variant = 'basic') {
    const enemy = document.createElement('div');
    enemy.classList.add('enemy');
    enemy.dataset.variant = variant;  // Good use of data attributes

    if (variant === 'basic') {
      enemy.classList.add('basic');
      enemy.textContent = '▾';
    } else if (variant === 'advanced') {
      enemy.classList.add('advanced');
      enemy.innerHTML = '<svg width="40" height="40"><ellipse cx="20" cy="20" rx="20" ry="10" fill="red" /><line x1="5" y1="10" x2="15" y2="0" stroke="black" stroke-width="2"/><line x1="25" y1="0" x2="35" y2="10" stroke="black" stroke-width="2"/></svg>';
    } else if (variant === 'boss') {
      enemy.classList.add('boss');
      const bossHealth = document.createElement('div');
      bossHealth.style.position = 'absolute';
      bossHealth.style.bottom = '-10px';
      bossHealth.style.left = '0';
      bossHealth.style.width = '100%';
      bossHealth.style.height = '5px';
      bossHealth.style.background = 'green';
      enemy.appendChild(bossHealth);
    }
      enemy.style.left = Math.random() * (gameContainer.clientWidth - 50) + 'px'; // Keep within bounds
      enemy.style.top = '0px';
      gameContainer.appendChild(enemy);
      enemies.push(enemy);
      moveEnemy(enemy); // Start moving immediately
    }


    function moveEnemy(enemy) {
       let enemyTop = enemy.offsetTop;  // Use offsetTop for consistent positioning
        const moveInterval = setInterval(() => {
         if (!gameRunning) {  // Stop moving if game is not running
           clearInterval(moveInterval);
           return;
        }
    enemyTop += 2;
    enemy.style.top = enemyTop + 'px';

    if (enemyTop > gameContainer.clientHeight) {
      enemy.remove();
        clearInterval(moveInterval); // Clear interval
       enemies = enemies.filter(e => e !== enemy); // Remove from array
      } else {
      checkPlayerCollision(enemy); // Check collision only if enemy is on screen
      }
   }, 25); // Slightly increased speed
}

  function checkPlayerCollision(enemy) {
    const playerRect = playerShip.getBoundingClientRect();
    const enemyRect = enemy.getBoundingClientRect();

    if (
      playerRect.right >= enemyRect.left &&
      playerRect.left <= enemyRect.right &&
      playerRect.bottom >= enemyRect.top &&
      playerRect.top <= enemyRect.bottom
    ) {
       // Collision
      enemy.remove();
      enemies = enemies.filter(e => e !== enemy);

     updateHealth(playerHealth - 20);
      flashDamage();
      screenShake();

        if (playerHealth <= 0) {
         gameOver();
       }
   }
 }



    // ===== Shooting =====
    function createBullet() {
      const bullet = document.createElement('div');
      bullet.className = 'bullet';
      const playerRect = playerShip.getBoundingClientRect();
      const containerRect = gameContainer.getBoundingClientRect();

      let bulletX = playerRect.left - containerRect.left + playerRect.width / 2 - 2.5;
      bullet.style.left = bulletX + 'px';
      bullet.style.bottom = '70px';

      gameContainer.appendChild(bullet);
      bullets.push(bullet);
      moveBullet(bullet);
    }

   function moveBullet(bullet) {
       let bulletBottom = parseInt(bullet.style.bottom) || 70;
      const moveInterval = setInterval(() => {
         if (!gameRunning) { // Stop if game stopped
         clearInterval(moveInterval);
           return;
          }
       bulletBottom += 5;
         bullet.style.bottom = bulletBottom + 'px';

         detectBulletCollision(bullet);
         if (bulletBottom > gameContainer.clientHeight) {
             bullet.remove();
               clearInterval(moveInterval);
                bullets = bullets.filter(b => b !== bullet);
            }
           }, 20); // Speed maintained.
       }



     function detectBulletCollision(bullet) {
      //Iterate backward.
         for (let i = enemies.length - 1; i >= 0; i--) {
           const enemy = enemies[i];
           const bulletRect = bullet.getBoundingClientRect();
             const enemyRect = enemy.getBoundingClientRect();

            if (
               bulletRect.right >= enemyRect.left &&
                bulletRect.left <= enemyRect.right &&
                bulletRect.bottom >= enemyRect.top &&
               bulletRect.top <= enemyRect.bottom
              )
        {
           // Collision detected
               createSpark(bulletRect.left, bulletRect.top);
               createDamageNumber(enemyRect.left, enemyRect.top, 10);
              updateScore(score + 10);
            enemyDeathAnimation(enemy);
               enemy.remove(); //Remove the enemy from DOM.
             enemies.splice(i, 1); // Remove the enemy from array.
          bullet.remove();  //remove the bullet from dom
                bullets = bullets.filter(b => b !== bullet); //remove bullet array
               return;   // VERY IMPORTANT: Exit after one hit.
         }
      }
   }
   function enemyDeathAnimation(enemy){
       const explosion = document.createElement('div');
       explosion.style.position = 'absolute';
        explosion.style.left = enemy.style.left;
        explosion.style.top = enemy.style.top;
         explosion.style.fontSize = '30px';
        explosion.style.color = '#fff';
      explosion.style.textShadow = '0 0 5px #ff0';
       explosion.textContent = '✸★✹';
         gameContainer.appendChild(explosion);

         // Use the animate API for the animation
         explosion.animate([{ opacity: 1 }, { opacity: 0 }], { duration: 500, fill: 'forwards' });

        setTimeout(() => explosion.remove(), 500); // Remove after the animation.

      }



    // ===== Keyboard Controls =====
  document.addEventListener('keydown', (e) => {
        if (!gameRunning) return;   // Only process if game started AND not paused
      if (gamePaused) return; // Don't move if paused

      if (e.key === 'ArrowLeft') {
         playerShipX = Math.max(0, playerShipX - 10);
         playerShip.style.left = playerShipX + 'px';
       }
      if (e.key === 'ArrowRight') {
        playerShipX = Math.min(gameContainer.clientWidth - 50, playerShipX + 10);
         playerShip.style.left = playerShipX + 'px';
    }

      if (e.code === 'Space') {
       createBullet();
       }

      if (e.key.toLowerCase() === 'p') { togglePause(); }
      });


    // ===== Game Control Functions =====
function startGame() {
   //Clear all previous interavls to be sure of not creating extras
   if (gameInterval) {
         clearInterval(gameInterval);
      }
      console.log("startGame() invoked");

        startScreen.style.display = 'none';
        gameOverScreen.style.display = "none"; //hide if restart game.
        gameRunning = true;  // Set game as running!

      // Reset game state (VERY important for restarts)
         score = 0;
      updateScore(0);
        playerHealth = 100;
       updateHealth(100);
     //Clear DOM
       enemies.forEach(enemy => enemy.remove());
      enemies = []; // Reset the enemies array.

        bullets.forEach(bullet => bullet.remove());
       bullets = [];  //reset bullets
      //Position Ship correctly for restarting
    playerShipX = 375;  //reset Player
     playerShip.style.left = playerShipX+ 'px';

       gameInterval = setInterval(() => {

          if(Math.random() < 0.03) createEnemy("basic");
          if (Math.random() < 0.01) { createEnemy('advanced'); }
         if (Math.random() < 0.001) { createEnemy('boss'); }
       }, 500); // Enemy Spawn rate
    }


    function togglePause() {
       gamePaused = !gamePaused; //toggle

       if (gamePaused) {
          clearInterval(gameInterval);
          pauseMenu.style.display = 'block';

    }   else {
        pauseMenu.style.display = 'none';
           // Resume the game loop without resetting
          gameInterval = setInterval(() => {

            if(Math.random() < 0.03) createEnemy("basic");
           if (Math.random() < 0.01) { createEnemy('advanced'); }
            if (Math.random() < 0.001) { createEnemy('boss'); }
             }, 500); // Maintain existing spawn rates

       }
     }

       function gameOver() {
        clearInterval(gameInterval); // Stop enemy spawns etc.
        gameRunning = false;      // Mark game as NOT running
        gameOverScreen.style.display = 'flex';  // Use 'flex' to display properly

    }
    // ===== Event Listeners =====
    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', startGame); // Now correctly restarts


    // ===== Easter Egg (No changes) =====

  </script>
</body>
</html>
