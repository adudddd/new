<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coastal Defense</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: sans-serif;
        }

        body {
            background-color: #87CEEB;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #game-container{
            position: relative;
            width: 800px;
            height: 600px;
            background-color: #f0e68c;
            border: 2px solid #a0522d;
            margin: 20px auto;
        }

        #player {
            position: absolute;
            bottom: 50px;
            left: 400px;
            width: 40px;
            height: 50px;
            background-color: transparent;
            z-index: 10;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
             display: flex;
             flex-direction: column;
             align-items: center;
        }

        #player::before, #player::after {
            content: '';
            position: absolute;
            background-color: #8B4513;
            width: 4px;
            height: 14px;
            bottom: 0px;
            border-radius: 2px;

        }

        #player::before { left: 6px;  }
        #player::after { right: 6px; }


        .walking-left {
           transform: scaleX(-1);
        }
        .walking-right{

        }

        #player-image{
            content: "üßë‚Äçüåæ";
            font-size: 30px;
            line-height: 50px;
            z-index: 200;
            position: absolute;
            width: 100%;

        }
         .player-leg-left, .player-leg-right{
        }


        .alien {
            position: absolute;
            background-repeat: no-repeat;
            background-size: contain;
            background-position: center;
        }
        .alien-drone {
            width: 40px;
            height: 40px;
            background-image: url('alien-drone.png');
            animation: float 2s infinite;
            z-index: 5;
        }

        .alien-shielded {
            width: 60px;
            height: 60px;
            background-image: url('alien-shielded.png');
            animation: pulseShield 3s infinite;
        }
        .shield{
           width: 100%;
           height: 100%;
           background-color: rgba(173, 216, 230, 0.6);
           z-index:6;
           position:absolute;
        }
        .alien-elite {
            width: 80px;
            height: 80px;
            background-image: url('alien-elite.png');
            animation: teleport 5s infinite;
        }
        .alien-boss {
            width: 120px;
            height: 120px;
            background-image: url('alien-boss.png');
            animation: bossCharge 10s infinite;
        }

        .health-bar-container {
            position: absolute;
            width: 40px;
            height: 5px;
            background-color: #555;
            border-radius: 2px;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 15;
        }

        .health-bar {
            height: 100%;
            background-color: green;
            width: 100%;
            border-radius: 2px;
            transition: width 0.3s linear, background-color 0.2s ease;
        }

        .health-bar.damage {
            background-color: red;
        }

        .resource {
            position: absolute;
            cursor: pointer;
        }

        .shell::after {
            content: "üêö";
            font-size: 20px;

        }

        .fish::after{
           content:"üêü";
           font-size: 20px;
        }
        .projectile {
            position: absolute;
            border-radius: 50%;
            z-index: 5;
         }
        .player-projectile {  }

        .melee-attack{
            width: 35px;
            height: 35px;
            background-color: rgba(255,0,0,0.7);
            animation: meleeSwing 0.3s forwards;
         }

        @keyframes meleeSwing {
          0% { transform:  scale(0) rotate(0deg); opacity: 0;}
          50% { transform: scale(1.3) rotate(180deg); opacity: 1; }
          100% { transform:  scale(0) rotate(360deg); opacity: 0; }
        }
         .ranged-attack{
             background-color: #007bff;
             width: 12px;
             height: 12px;
         }
         .special-attack{
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255,255,0, 0.6);
            animation:  specialExpand 0.7s ease-out forwards;

         }

         @keyframes specialExpand{
             0%{ transform: scale(0);}
            100% { transform: scale(1.5);  opacity: 0; }

         }
        #ui-container {
            width: 800px;
            margin: 0 auto;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: space-between;
            align-items: center;

        }
        #controls{
        }
        #inventory {
           display: flex;
           gap: 15px;

        }

        #wave-info {

        }

        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border: 2px solid #333;
            border-radius: 8px;
            z-index: 1000;
            display: none;
        }

        #message-text {}
        #message-options{
          display:flex;
          justify-content:center;
        }

        #game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        #game-over-content {
            background-color: white;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
        }

        #game-over-content h2 {}

        #game-over-content button {}

        .defense {
            position: absolute;
        }

        .barrier {
            width: 50px;
            height: 20px;
            background-color: brown;
            border: 1px solid black;
        }
          .turret {
              content:"üóº";
               font-size: 35px;

          }

           .healing-station {
            content:"‚ûï";
            font-size:35px;

        }
           .house {
             position: absolute;
            width: 80px;
            height: 70px;
            background-color:  #ffd1dc;
            border: 4px solid brown;
             left: 20px;
             bottom: 50px;
           }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        @keyframes pulseShield {
             0%, 100% {opacity: 1; }
             50% { opacity: 0.3; }
         }

        @keyframes teleport {
           0%, 100% { opacity: 1;}
            49% { opacity: 1; }
            50% { opacity: 0;}
            99% { opacity: 0;}
        }


          @keyframes bossCharge{

            0%{ transform: translateX(0);}
            50%{ transform: translateX(-450px)}
           100% {transform: translateX(0); }
        }


    </style>
</head>
<body>
    <div id="game-container">
        <div id="player">
          <div id = "player-image"></div>
            <div class = "health-bar-container">
               <div class = "health-bar player-health"> </div>
            </div>
        </div>

          <div class="house" id="house"> </div>


    </div>
     <div id="ui-container">
            <div id="controls">
                <button id="melee-attack-btn">Melee</button>
                <button id="ranged-attack-btn">Ranged</button>
                <button id="special-attack-btn">Special</button>
                <button id="build-barrier-btn">Barrier</button>
                <button id = "build-turret-btn">Turret</button>
                <button id = "build-healingstation-btn">Healing Station</button>
                <button id="upgrade-button">Upgrades</button>
            </div>
            <div id="inventory">
                 <div>Shells: <span id="shell-count">0</span></div>
                 <div>Fish: <span id="fish-count">0</span></div>

            </div>
            <div id="wave-info">
                Wave: <span id="wave-number">1</span>
            </div>
       </div>

       <div id="message-box">
          <div id="message-text"></div>
          <div id = "message-options">
           </div>
        </div>

        <div id="game-over-overlay">
            <div id="game-over-content">
                <h2>Game Over!</h2>
                <p id="game-over-reason"></p>
                <button id="restart-button">Restart</button>
            </div>
        </div>

    <script>
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        const PLAYER_SPEED = 5;
        const PROJECTILE_SPEED = 8;
        const WAVE_INTERVAL = 5000;

        let player;
        let aliens = [];
        let resources = [];
        let projectiles = [];
        let defenses = [];
        let gameInterval;
        let waveNumber = 0;
        let isGameOver = false;
        let gameActive = false;

        let playerState = {
            x: GAME_WIDTH / 2,
            y: GAME_HEIGHT - 50,
            health: 100,
            shells: 0,
            fish: 0,
            upgradePoints: 0,
            attackDamage: {
                melee: 15,
                ranged: 10,
                special: 30,
            },

        }

         let houseState = {
            health: 100,
            maxHealth: 100,
        }
         let paused = false;

        let waveConfig = [
              { enemies: [{type: 'drone', count: 3 }] },

              { enemies: [{type: 'drone', count: 5}]},

              { enemies: [{type: 'drone', count: 2 }, {type: 'shielded', count: 1} ]},

            { enemies: [{type: 'drone', count: 3 }, {type: 'shielded', count: 2}]},

            { enemies: [ { type: 'shielded', count: 3 }, { type: 'elite', count: 1 } ]},
            { enemies: [{type: 'elite', count:3}]},
            { enemies: [{type: 'boss', count:1}]}
        ];
         let nextWaveTimer;
        const gameContainer = document.getElementById('game-container');
        const playerImage = document.getElementById('player-image');
        const uiContainer = document.getElementById('ui-container');
        const shellCountDisplay = document.getElementById('shell-count');
        const fishCountDisplay = document.getElementById('fish-count');
        const waveNumberDisplay = document.getElementById('wave-number');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const messageOptions = document.getElementById('message-options');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const gameOverReason = document.getElementById('game-over-reason');
        const restartButton = document.getElementById('restart-button');

        const meleeAttackBtn = document.getElementById('melee-attack-btn');
        const rangedAttackBtn = document.getElementById('ranged-attack-btn');
        const specialAttackBtn = document.getElementById('special-attack-btn');
        const upgradeButton = document.getElementById('upgrade-button');
        const buildBarrierBtn = document.getElementById('build-barrier-btn');
        const buildTurretBtn = document.getElementById('build-turret-btn');
        const buildHealingStationBtn = document.getElementById('build-healingstation-btn');
        const pauseBtn = document.getElementById('pause-button');

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 50;
                this.element = document.getElementById('player');
                this.isMovingLeft = false;
                this.isMovingRight = false;

            }

            update() {
                if (this.isMovingLeft && this.x > 0) {
                   this.x -= PLAYER_SPEED;

                   playerImage.parentElement.classList.add('walking-left');
                   playerImage.parentElement.classList.remove('walking-right');

                }
                 if (this.isMovingRight && this.x < GAME_WIDTH - this.width) {
                    this.x += PLAYER_SPEED;

                    playerImage.parentElement.classList.add('walking-right');
                    playerImage.parentElement.classList.remove('walking-left');
                }

                this.render();
            }

            render() {
                this.element.style.left = `${this.x}px`;
                this.element.style.bottom = `${GAME_HEIGHT - this.y - this.height}px`;
            }

        }
         class Resource{
             constructor(x, y, type){
                 this.x = x;
                 this.y = y;
                 this.type = type;
                 this.width = 20;
                 this.height = 20;
                 this.element = document.createElement('div');
                 this.element.classList.add('resource', type);
                 this.element.style.left = `${this.x}px`;
                 this.element.style.bottom = `${this.y}px`;
                 this.element.onclick = () => this.collect();
                 gameContainer.appendChild(this.element);
            }
            collect(){

             if (this.type === 'shell'){
                  playerState.shells++;
             }else if (this.type === 'fish'){
                 playerState.fish++;
             }

                this.remove();
                updateUI();

            }
             remove(){
              this.element.remove();
              resources.splice(resources.indexOf(this), 1);
             }
         }


        class Alien {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.speed = 1;
                this.health = 100;
                this.attackPower = 10;
                this.attackPattern = [];
                this.isAttacking = false;
                this.attackCooldown = 1500;
                this.nextAttackTimer = null;

                this.element = document.createElement('div');
                this.element.classList.add('alien', `alien-${type}`);
                switch (type) {
                    case 'drone':
                        this.health = 50;
                        this.speed = 1.2;
                         break;
                    case 'shielded':
                        this.width = 60;
                        this.height = 60;
                        this.health = 120;
                        this.speed = 0.8;
                        this.attackPower = 15;
                        this.hasShield = true;
                        break;
                    case 'elite':
                        this.width = 50;
                        this.height = 50;
                         this.health = 80;
                        this.speed = 2;
                         this.attackPower = 20;
                        break;
                    case 'boss':
                         this.width = 100;
                         this.height = 100;
                         this.health = 300;
                         this.speed = 0.9;
                        this.attackPower = 35;
                         break;
                }
                 this.healthBarContainer = document.createElement('div');
                this.healthBarContainer.classList.add('health-bar-container');

                this.healthBarElement = document.createElement('div');
                this.healthBarElement.classList.add('health-bar');

                this.healthBarContainer.appendChild(this.healthBarElement);
                this.element.appendChild(this.healthBarContainer);
                if (this.hasShield) {
                    this.shieldElement = document.createElement('div');
                    this.shieldElement.classList.add('shield');
                    this.element.appendChild(this.shieldElement);
                }

                gameContainer.appendChild(this.element);
                this.render();
                this.startAI();
            }

            update() {
                if(!paused) this.moveTowardsPlayer();

                this.render();
            }

            render() {
                this.element.style.left = `${this.x}px`;
                this.element.style.bottom = `${this.y}px`;

                const healthPercent = (this.health / this.getMaxHealth()) * 100;
                this.healthBarElement.style.width = `${healthPercent}%`;
                 if(healthPercent <= 25){
                   this.healthBarElement.style.backgroundColor = 'red';
                } else if (healthPercent <= 50){
                   this.healthBarElement.style.backgroundColor = 'orange';
                }
                else{
                    this.healthBarElement.style.backgroundColor = 'green';
                }
            }

            startAI() {
                if (this.moveInterval) {
                    clearInterval(this.moveInterval)
                 }

                this.moveInterval = setInterval(() => {
                    this.moveTowardsPlayer();
                }, 50);

                this.scheduleNextAttack();

            }
              scheduleNextAttack(){

                 if (this.nextAttackTimer) {
                       clearTimeout(this.nextAttackTimer);
                  }

                this.nextAttackTimer =  setTimeout(() => {
                    if (this.distanceToPlayer() < 100) {
                           this.attackPlayer();
                    }
                   this.scheduleNextAttack();

                 }, this.attackCooldown);
             }
            moveTowardsPlayer() {
               if (!gameActive || isGameOver) return;

                 if (!this.canMove()) return;
                 const playerX = player.x + player.width / 2;
                const playerY = player.y + player.height/ 2;

                 const dx = playerX - (this.x + this.width/2 );
                const dy = playerY - (this.y + this.height /2 );

                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 5) {

                      const moveX = (dx / dist) * this.speed;
                     const moveY = (dy / dist) * this.speed;

                   this.x += moveX;
                   this.y += moveY;
                }

                if(isColliding(this, {x: houseState.x, y: houseState.y, width: 80, height: 70} )){

                    damageHouse(this.attackPower/40);

               }

            }
             canMove(){
                  return true;
             }

             distanceToPlayer(){

                  const playerX = player.x + player.width/2;
                const playerY = player.y + player.height/2

                  const dx = playerX - (this.x + this.width / 2);
                  const dy = playerY - (this.y + this.height/2);

                 return Math.sqrt(dx * dx + dy * dy);
              }

            attackPlayer() {
              if (isGameOver || !gameActive) {return};

                 if (!this.isAttacking){
                     this.isAttacking = true;
                    this.element.classList.add('attacking');
                   switch(this.type){

                      case 'drone':

                           damagePlayer(this.attackPower);

                           break;
                       case 'shielded':

                          damagePlayer(this.attackPower);

                           break;
                       case 'elite':
                            damagePlayer(this.attackPower)

                           break;
                      case 'boss':

                       damagePlayer(this.attackPower);

                          break;
                    }
                     setTimeout(() => {

                         this.element.classList.remove('attacking');
                        this.isAttacking = false;

                     }, 500);

                   }

            }

            takeDamage(damage) {
                if (this.hasShield) {
                    if (Math.random() < 0.5) {
                        showMessage('Shield blocked!',[{text: 'Ok', action:closeMessage}])
                      return;
                    }
                }

                 if (!isGameOver && gameActive)
                    this.health -= damage;

                if (this.health <= 0) {
                    this.health = 0;
                    this.die();
                    return;
                }
                this.render();
            }

            die() {

               if (this.element) this.element.remove();

              if(this.nextAttackTimer)  clearTimeout(this.nextAttackTimer);
              clearInterval(this.moveInterval);

                aliens = aliens.filter(a => a !== this);

                if (Math.random() < 0.5) {

                     let dropType = Math.random() < 0.5 ? 'shell':'fish';

                    const resource = new Resource(this.x, GAME_HEIGHT - this.y, dropType);
                    resources.push(resource)

               }

                checkWaveCompletion();
            }

            getMaxHealth(){

                  switch(this.type){

                     case 'drone':  return 50;

                    case 'shielded': return 120;
                   case 'elite': return 80;

                   case 'boss':  return 300;
                 }
               return 100;
           }

            adapt(attackType) {
                if (attackType === 'melee' && !this.attackPattern.includes('dodgeMelee')) {

                   this.attackPattern.push('dodgeMelee');
                }

           }


            tryDodge(attackType) {
                if (attackType === 'melee' && this.attackPattern.includes('dodgeMelee')) {

                     let moveX = Math.random() < 0.5 ? -30: 30;

                     this.x += moveX;

                      this.x = Math.max(0, Math.min(this.x, GAME_WIDTH-this.width))

                     return true;
                 }
             return false;
             }

        }

        class Projectile{
                constructor(x, y, targetX, targetY, speed, damage, attackType = 'normal', source) {

                this.x = x;
                this.y = y;

                this.targetX = targetX;
                this.targetY = targetY;

                this.speed = speed;
                this.damage = damage;

                 this.width = 10;
                 this.height = 10;

                 this.attackType = attackType;

                 this.element = document.createElement('div');

                this.element.classList.add('projectile');

                if(source === "player"){
                    this.element.classList.add('player-projectile');
                  }

                this.element.style.left = `${this.x}px`;

                gameContainer.appendChild(this.element);

                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;

                const distance = Math.sqrt(dx*dx + dy * dy);
                this.velocityX = (dx/distance) * this.speed;
                this.velocityY = (dy/distance) * this.speed;
                this.hasHit = false;
           }

                update(){
                   if(!gameActive) return;
                     this.x += this.velocityX;
                    this.y += this.velocityY;


                  if(this.x < 0 || this.x > GAME_WIDTH || this.y < 0 || this.y > GAME_HEIGHT || this.hasHit){

                    this.remove();
                    return;
                  }

                if (this.element.classList.contains('player-projectile')){

                   for(const alien of aliens){

                         if (isColliding(this, alien) ){
                          alien.takeDamage(this.damage);
                          this.hasHit = true;
                          this.remove();
                          return;

                              }
                       }
                   }
            this.render();
          }

           render(){
               this.element.style.left = `${this.x}px`;
               this.element.style.bottom = `${this.y}px`;
            }


            remove(){
               this.element.remove();
              projectiles = projectiles.filter(p => p!== this);

                }
         }
        class Defense {
            constructor(x, y, type) {

                this.x = x;
                this.y = y;
                this.type = type;
                 this.element = document.createElement('div');
                this.element.classList.add('defense', this.type);
                 switch(type) {
                      case 'barrier':

                           this.width = 50;
                           this.height = 30;

                           break;

                   }

                  gameContainer.appendChild(this.element);
                   this.render();
             }

              render(){
               this.element.style.left = `${this.x}px`;
                this.element.style.bottom = `${this.y}px`;
           }

        }
        function showMessage(text, options) {
              messageText.textContent = text;
              messageOptions.innerHTML = '';

              if (options && options.length>0) {
                 options.forEach(opt => {
                     const button = document.createElement('button');
                      button.textContent = opt.text;
                     button.onclick = opt.action;
                      messageOptions.appendChild(button);
                });
              } else {
                const defaultButton = document.createElement('button')
                defaultButton.textContent = 'OK';
                defaultButton.onclick = closeMessage;
                messageOptions.append(defaultButton)
             }
              messageBox.style.display = 'block';

        }
         function closeMessage() {

              messageBox.style.display = 'none';
          }

          function isColliding(entity1, entity2){

                 const rect1 = entity1.element ? entity1.element.getBoundingClientRect() : entity1;
                const rect2 = entity2.element ? entity2.element.getBoundingClientRect(): entity2;

               return !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top ||  rect1.top> rect2.bottom)
           }

            function spawnWave() {

                  if (isGameOver || currentWaveIndex >= waveConfig.length) {

                    return;
                   }

                    const currentWaveData = waveConfig[currentWaveIndex];
                   waveNumber++;

               showMessage(`Wave ${waveNumber} incoming!`, [
                  { text: 'Prepare', action: closeMessage },
                 ]);

               activeAliens.forEach(a => {
                     if(a && a.element)
                          a.element.remove();
                 });

                 aliens = [];

                 currentWaveData.enemies.forEach(enemyGroup => {
                    for (let i = 0; i < enemyGroup.count; i++) {

                       const xOffset = i * 50;
                       const yOffset = 0
                        const alien = new Alien(enemyGroup.type, GAME_WIDTH - 50 - xOffset, GAME_HEIGHT - 50-yOffset); // Initial position based wave data!
                        aliens.push(alien); // Add all ALIEN Instances to ARRAY for handling

                    }
                });
                currentWaveIndex++; // Prepare *NEXT WAVE DATA* (increment!)
            }

            function checkWaveCompletion() {

             if (aliens.length === 0) {

                   updateUI();  // Resource count! (Can make upgrade appear with some chance too)
                    showMessage(`Wave ${waveNumber} Complete!`, [ { text: "Next Wave", action: ()=> {
                       // Can *add upgrade phase now as separate function!, or automatically spawn

                       spawnWave(); /* Automatic: */

                    }

                   } ])

                }
             }

        function damagePlayer(damage) {
            if(!gameActive || isGameOver) return;

            playerState.health -= damage;
            if (playerState.health <= 0) {
                playerState.health = 0;
                gameOver("Player defeated!"); //
                return;
            }
             updateUI();
        }

        function damageHouse(damage) {

             if(!gameActive || isGameOver) return;

           houseState.health -= damage;

          if (houseState.health <= 0) {
               gameOver("House destroyed!"); // End game *specific reason message (House/Player) - refine text!
               return;
           }

          updateUI(); // Reflect Change
      }
        function gameOver(reason) { //
            isGameOver = true;
            gameActive = false; // Stop updates.
            clearInterval(gameInterval); // VERY IMPORTANT - Prevent future WAVE spawns or continued running update
            clearTimeout(nextWaveTimer);
             aliens.forEach(a => {
               a.stopAI()});

             gameOverReason.textContent = reason; // Player lost, *show why* - House vs Monster killed?
            gameOverOverlay.style.display = 'flex'; // show overlay and content, centered nicely, absolute

        }
       function gameWon() {  /* Victory! */
            gameActive = false;

           /* Similar Overlay show + score: - if need expand*/
           /* aliens.forEach(a => { // If any remain due to collision and death.

            }); */

       }
       function createProjectile(startX, startY, targetX, targetY, damage, attackType = 'normal', source = 'player') {
             const projectile = new Projectile(startX, startY, targetX, targetY, PROJECTILE_SPEED, damage, attackType, source );
              projectiles.push(projectile); // Tracking the "active Bullets", like for Enemy to remove from List!

        }

        function performAttack(attackType) {
          if(!gameActive || isGameOver || paused ) return;  /* Game State checks: no attacks in pause, over etc.*/

            if (aliens.length === 0) return;  // no target, return

              const closestAlien = findClosestAlien(); // Helper

               // Attack visuals centered on PLAYER for Melee and Special - same X position! */

               const attackVisual = document.createElement('div');
               attackVisual.classList.add('attack-visual');  // ALWAYS give attackVisual!

            let damage = 0;

           switch(attackType){
                case 'melee':

                 damage = playerState.attackDamage.melee;
                 /* VISUAL Melee, and play at that Position - then disappear/automatic cleanup by CSS Keyframes set already in CSS itself (with appropriate animation)
                /* Example: */

                   attackVisual.classList.add('melee-attack'); // Melee effects! Add Animation as you like (visuals + sound later), but it will set class
                 // offset by height. NOTE  Y value = where we have the START bottom Point

                   attackVisual.style.left = `${player.x}px` // player center point
                    attackVisual.style.bottom = `${GAME_HEIGHT - player.y}px` // Consistent BOTTOM system to handle/control offsets (player is using same coordinates)

                    gameContainer.appendChild(attackVisual); // Put to Main game so positioning relative


                /* Remove VISUAL when Melee completes - here, automatic after set in STYLE/keyframes (set by classes, which define behavior/properties per *type*) */
                   setTimeout(()=>{
                         if(attackVisual && attackVisual.parentElement){ /*Check existence*/
                              attackVisual.remove(); /* Very crucial - after *each*, CLEANUP*/
                          }
                  }, 300);   /* .3s animation for MELEE hit feedback, *Match CSS melee duration now * (easier maintenance - values in SAME part).  */
                 break;

                case 'ranged': /* For the Bullet*/

                damage = playerState.attackDamage.ranged;

                 /* Calculate where the Player actually shoot AT: */// ... (previous code) ...

                case 'ranged':
                    damage = playerState.attackDamage.ranged;

                    // Aim at the *closest* alien.  More advanced targeting could be implemented.
                    if (closestAlien) {
                        // Adjust starting position slightly to originate from "gun" (visual offset).
                        const startX = player.x + player.width / 2;
                        const startY = GAME_HEIGHT - player.y - player.height / 2;

                        // Target the *center* of the closest alien.
                        const targetX = closestAlien.x + closestAlien.width / 2;
                        const targetY = GAME_HEIGHT - closestAlien.y - closestAlien.height / 2; // Consistent bottom-based y

                        createProjectile(startX, startY, targetX, targetY, damage, 'normal', 'player');
                    }
                    break;

                case 'special':
                    damage = playerState.attackDamage.special;

                    attackVisual.classList.add('special-attack');

                    attackVisual.style.left = `${player.x - 30 + player.width/2}px`; //initial expansion, will use animation after setting. No need "offset here, because start from ZERO SIZE
                    attackVisual.style.bottom = `${GAME_HEIGHT-player.y - 30}px`;// Start where player currently, + size offset
                    gameContainer.appendChild(attackVisual);

                    setTimeout(() => {  // removal after effect end. MATCH style
                       if(attackVisual && attackVisual.parentElement){
                           attackVisual.remove();

                      }

                     }, 700);

                   // Apply Damage within an Area of Effect: All nearby

                   aliens.forEach(alien => {  // DAMAGE multiple

                    if (distanceBetween(player, alien) < 100){
                     alien.takeDamage(damage); /* apply, check consequences if dead (will manage array removal. */
                    }
                    })
                    break;
           }

        }
      function findClosestAlien() { // VERY useful helper:  Get the nearest ALIVE
             if (aliens.length === 0) {
                  return null;
              }

               let closest = aliens[0]; // default start compare.
                let closestDist = distanceBetween(player, closest);  // start to set up min dist.
               for (let i = 1; i < aliens.length; i++) {
                   const dist = distanceBetween(player, aliens[i]);
                 if (dist < closestDist) { /* BETTER!  (shorter distance */
                    closestDist = dist; // new minimum.
                     closest = aliens[i];
                  }
                }
             return closest; // Found
         }

       function distanceBetween(entity1, entity2){ // can calculate dist BETWEEN ANY TWO Entities.  Avoid complex repeated properties accesses
            const dx = (entity1.x + entity1.width/2) - (entity2.x+ entity2.width /2 );
            const dy = (entity1.y + entity1.height/2) - (entity2.y+ entity2.height/2);  /* IMPORTANT  Consistent center based to handle attack area check etc  - for circle/etc */

             return Math.sqrt(dx*dx + dy*dy);

        }

        function updateUI() {
            shellCountDisplay.textContent = playerState.shells;
            fishCountDisplay.textContent = playerState.fish;
            waveNumberDisplay.textContent = waveNumber;
            //Update Upgrade point too.
            /*
            Update House Health visual: could set class, size if NO image.   .house--damaged
            if (houseState.health <= 50 ){  } // change color of a class for visual, apply DAMAGE
             OR (direct/simple method, not requiring more HTML nodes/nested divs)

              e.g.: simple Size REDUCE for health reduction, visual */

                const houseVisual = document.getElementById('house'); // the main HTML tag - ensure the main Element exists

              // style
              // houseVisual.style.backgroundColor = 'red'; // change COLOR
               // Scale SIZE of visual of the whole house, OR its specific internal Elements/borders!
            // Adjust WIDTH. Use %:

                const houseHealthPercent = (houseState.health/houseState.maxHealth)*100 // Ensure that value used.
                houseVisual.style.width = `${houseHealthPercent}%`;  // use Percent, of that parent! OR can be pixel (consistent)

           const playerHealthPercent = (playerState.health/100)*100 // Max 100 hardcoded - future can track this max differently, same as enemy.
            document.querySelector('.player-health').style.width = `${playerHealthPercent}%` // very important update value too, from game-logic number/object states to user-facing VIEW
            // if less 25%

           if(playerHealthPercent <= 25){
             document.querySelector('.player-health').style.backgroundColor = 'red' // danger warning
           } else if (playerHealthPercent<= 50){

            document.querySelector('.player-health').style.backgroundColor = 'orange';
          } else{

             document.querySelector('.player-health').style.backgroundColor = 'green'//reset! VERY important!
         }


        }

        function showUpgrades() { // Display Menu and options

             if(playerState.upgradePoints <= 0){ // guard

                showMessage("No Upgrade Points!",[{text: 'OK', action:closeMessage}]); // No complex object/class method dependency.
                return;
              }

             // Otherwise CAN continue display menu

              const options = [

                    {text: "Sword (+10 Melee Damage, 10pts)", action: () => upgradeWeapon('melee') }, //bind for player, ensure player context for state updates/upgrades
                    {text: "Bow (+5 Ranged Damage, 8pts)", action: () => upgradeWeapon('ranged') },
                     //... MORE OPTION: for different upgrade PATH
                      {text: 'Cancel', action: closeMessage } /* ALWAYS: can exit! *crucial  */

              ]
                 // OR separate upgradeSpecialAttack("duration", 2, ) - where increases more property (or for magic effects like 'radius') - requires MORE upgrade menu logic. */

                  /* Future/Complex:

                       More Menu Option could add DEFENSES - Barriers etc.

                   */

              showMessage(`Upgrades: ( ${playerState.upgradePoints} Points)`,options);

          }
          /* Upgrade/modify Player ATTACK STAT */

         function upgradeWeapon(type){ // simple cost, direct set
            let upgradeCost = 0;
            let upgradeAmount = 0; // Amount of damage to add *as increase */
              switch(type){  // handle the STATS for game *tuning*.
                  case 'melee':  // direct damage upgrade

                     upgradeCost = 10;  // COST point value. If have many type - can move these rules (Cost, change/upgrade benefit, prerequisites) into Game Data Structure (class, static value for properties) or global game config constant.
                       upgradeAmount = 10;
                      break;  /* Add More Options HERE if wanted for the sword upgrade */

                   case 'ranged':  // for shooting

                     upgradeCost = 8;
                    upgradeAmount = 5;

                     break; /* and Other Bow-specific UPGRADES. e.g. attack Speed */
                /*

                  Expand logic HERE: E.g. different effects, multiple weapon can get other attack *types (e.g. shot fire, etc)

                */

            } // Upgrade Cost can vary and rules can be applied:

             // Guard:  FIRST CHECK and return
             if(playerState.upgradePoints< upgradeCost){ // canNOT perform Action: Player's Resource state DOESN'T Match.
                 showMessage("Not enough Points!", [{text: 'OK', action: showUpgrades}]); /* Can Show AGAIN */
               return;
              }
             // After CHECKS (and can "chain them", but return after failure prompt) - APPLY UPGRADE/game benefit

              playerState.upgradePoints -= upgradeCost; // FIRST, apply Player Resource Cost.

               playerState.attackDamage[type] += upgradeAmount; // *Increase* stats on appropriate object *

                // Confirm

              showMessage("Upgraded! +"+upgradeAmount +"  to: " + type, [{text: 'Continue', action: closeMessage}]);
             updateUI();

         }

       function placeDefense(type){ /* Very Basic Example: Place *Structure at Click */
         // NOT in "upgrade weapon menu"

             if(playerState.shells < 5){  // If cost require Fish + some Shell: can be 'complex price tag', not simple constant points like for attack increases/upgrades, so flexible for new resource (
                    // ... Can't perform action now - could make multiple checks
               return;
             }

            // Get where was tapped (could use TouchEvent in addEventListener *also*, change Event type if touch ONLY
             // (on touch: e.client/Y gives coordinates similar-mobile game.)
           document.addEventListener('click', function buildHandler(event){
               if(type == "barrier"){
                 const barrier = new Defense(event.offsetX, GAME_HEIGHT-event.offsetY, 'barrier') // can create at current position (CLICK POINT is relative *inside CONTAINER - all game use same positioning rule consistent!)
                  defenses.push(barrier);
               }
                if(type == 'turret'){
                    const turret = new Defense(event.offsetX, GAME_HEIGHT-event.offsetY, 'turret')
                 defenses.push(turret)
                }

                document.removeEventListener('click', buildHandler) // Ensure NOT Multi call for each
               // place that clicked after set. (more structured way can also define: in a Player-mode. E.g., player has State = BUILDING/selecting type to perform (button trigger/event can add properties like current Mode: place barrier) AND when complete placing: switch that off, back to null). If wanted "free select any where on screen, AND THEN decide build here
                 //   e.g. when player mode: can use move, if right place, add build
           })

       }
          /*   Expand for more "cost-per structure (if need refine resource values), different placements (Turret and Barricade) - game content/strategy tuning.  */

           // can have Barrier *different shape* - if barrier can be 5 "tile wide for some, BUT needs COST adjustment to avoid "1 tap 10 width instantly */


        // --- Game Loop (Update and Render) ---
        function gameLoop() {
             if (!gameActive) return;
             /*if (paused) return; // Check Global: If in other mode - MENU option etc.*/
             // Note: if too many calls cause slow/lag performance. (IF many nested for/loops *each game loop*, too many iterations)

               /* Check collision! Projectile hit (as "immediate"), in own *separate* Class updates
                   (each bullet manages self check every tick )  *Separate, not here
                */

               /* NOTE. Can do this for multiple Object, for convenience, at Once (iterate one, loop) :

                 */

                 // Instead of repeat blocks per object. IF adding new game Elements - all needs "updating/frame logic".

               /* Use loop as more ROBUST:

                    ALL that is *currently alive, track and perform

               /*
                  Example structure,
                 [player, ...aliens].forEach(entity => { // Ensure no Nulls if not spawned properly!
                 updateEntity(entity) / render...
                 // call OTHER properties here too, e.g.: UpdateStateEffects - IF need logic in Game to reduce Countdowns, set states etc

                  })
                */


                player.update();
                projectiles.forEach(p => p.update()); // Bullets/other will call own "Check" every time (Move OR collide and be Removed if did *or expired )
                aliens.forEach(alien => alien.update());

                updateUI();

        }


        function startGame() { //

          gameActive = true;  // First
             player = new Player(playerState.x, playerState.y);
             player.render();

             // Setup EVENT for INPUT KEY Handling. - Better with centralized/game *focused logic.
           document.addEventListener('keydown', handleKeyDown); // SET ONLY *once*
          document.addEventListener('keyup', handleKeyUp);

             /* Very important: BUTTON event listener  */

           meleeAttackBtn.addEventListener('click', ()=> {
                 performAttack('melee');
                })
           rangedAttackBtn.addEventListener('click', ()=> {  // SAME, and Ensure Correct 'attack mode passed'.
              performAttack('ranged')

           })

           specialAttackBtn.addEventListener('click', ()=>{
              performAttack('special') // Very IMPORTANT use "switch cases in Perform to check which WAS Clicked: *NO MIX*.
            })

           /* BUTTON: Defense PLACEMENT on Scene */
           buildBarrierBtn.addEventListener('click', ()=> {placeDefense('barrier')}) /* Add defense *type*.   NOTE : Cost of RESOURCE/Gold per defense type needs logic in *that placement!*.  NOT in Player upgrade.    IF need separate Upgrade Path and currency - can create as menu here - similar to upgradeWeapon structure!*/

             // Similar : turret.  But more complex for visual changes
          // buildTurretBtn =
          //  buildHealingStationBtn = document.getElementBy....

             upgradeButton.addEventListener('click', showUpgrades);  // when Player Clicks: menu UP


            restartButton.addEventListener('click', restartGame);

           /* --- CORE Gameplay after Start */

            showMessage("Wave incoming!", [{text: 'Start', action: closeMessage}]);

            spawnWave(); // begin FIRST Wave immediately! *Initial Call* - VERY crucial

           /* *GAME LOOP* Very CRITICAL:

                setInterval (will REPEAT calls) that Run update/checks (AI actions)

            *Start*: Call AFTER Set all Up and Initial Spawns for Enemies. */

           gameInterval = setInterval(gameLoop, 1000 / 60); // *60 times a second*, FPS-rate control. For smooth animation/consistent *Update Check: Game State *and visuals refreshed (player moves AND all Alien move - this allows "multi entity behaviors!) */


         // e.g.  Spawn  *New Resource*/ every *SOME* number of times game loop  check OR, set on *game TIME*: every 5 second can re-spawn Shell etc (for crafting, upgrade-currencies)
        }

         /*  Handles KEY: Player control MOVES. */
          function handleKeyDown(event) {

               if (event.key === 'ArrowLeft' || event.key === 'a') {
                  player.isMovingLeft = true;  /* NOTE : isMoving, BUT move *actually happen/apply  PER frame*

                     /* For *better and simple *animations: just Swap Classes as in Example */
                } else if (event.key === 'ArrowRight' || event.key === 'd') {
                    player.isMovingRight = true; /* VERY CRUCIAL - Ensure RIGHT key (could be d, on d/q keyboard if set up that too!*/
                 }


                /*
                   Could add  OTHER Key event to add logic!

                     Example if using DEFENSIVE actions later, Player state *based on ability

                 //e.g:

                  if (player.Shielded){  or // check if player currently using
                      do something. e.g., can NOT also perform other move action/attacks
                  }
              */


                /* Alternative "ALL actions here in Keys" version : BUT, button click BETTER */
               /*
             if(event.key === " "){ /*  Melee example

                  if (player can Do Attack ) - some Cooldown system too (so no repeating every millisecond

                 performAttack("melee")
               }

            if ( event.key ===... (Other ability.)) {


               However this is HARD to organize if having different/multiple keys

               Consider that Button approach:  Can define Attack(and send in WHICH one, name as text);   Much *more robust way, cleaner! */
        }
        function handleKeyUp(event) { // Stop *CONTINUOUS*. VERY *CRUCIAL, other, player move EVEN AFTER let key! *BUG if Not. */
             if (event.key === 'ArrowLeft' || event.key === 'a') {

                  player.isMovingLeft = false;  // Player  release: immediately  *prevent move/cancel  *. VERY Crucial!! *avoid keeping State/Move on key released*

                  /* if need add class/styling switch : E.g. for "Stop animation after Key no more. - (and other visual)

                    player.style... (OR set back DEFAULT class - back to STAND/idle!)

                  */

               } else if (event.key === 'ArrowRight' || event.key === 'd') {

                     player.isMovingRight = false; // Key Up = release Action to move in any dir - No *other direction keys check*

                     /* could expand later : other Animation logic for stop player animation

                     */
              }

          /* Check ALSO  other KEY releases if expand Game -  so does NOT keep doing something on Release! e.g., do not KEEP creating projectiles in that one spot of Attack  if Player Key up - and have to do Action on *next game-frame/tick update loop!.

        }
  */
}
        function restartGame() {
          //RESET GAME states: NO keep aliens/progress
            aliens.forEach(a => a.element.remove()); // cleanup for old wave *before restarting New! VERY Crucial!
           aliens = [];
          projectiles.forEach(p => p.remove());
          projectiles = [];  // new game = CLEAR

          // clear interval IF keep going
            isGameOver = false;
            gameActive = false; // set start to *TRUE

            playerState.health = 100;  // reset
            houseState.health = 100;
             waveNumber = 0;
           currentWaveIndex = 0; // Crucial
           // resource count.
           playerState.shells = 0;  //reset
           playerState.fish = 0;

           /* *Crucial, after SET values - ensure UPDATE View as restart!. */
             updateUI();

          gameOverOverlay.style.display = 'none'; // hide Game Over *UI*
          /* Reset position/any player changes from previous round
                // (OR use 'spawn' at start again/re create PLAYER completely!)
           // */

          /* Clean any active projectiles too for clear up between Game Reset (bullet left alive while time run out etc*/
            startGame();
        }
        // Initial setup
        function init() {
             // Placeholder for the house

            houseState.x = 20; // Define within object as Properties so it exists consistently, just update value of state - if keeping SAME type!
             houseState.y = 50;  // Same, bottom = Consistent and Easy for check relative distances in isColliding helper!  Just set/refer to value here!

            document.getElementById('house').style.left = `${houseState.x}px` /* Apply the x. Ensure house render with those STATE properly from initial */
           document.getElementById('house').style.bottom =  `${houseState.y}px`

          // setup *resources * before play

           updateUI();
           /*
           More set/value adjustments if expand.

           But better/structured: Move init call INTO other Function Call, at GameStart Button Trigger!
          // */


        }

        // Start the game when the page loads
        window.onload = function() {
           init() // Initial setting up!
            showMessage("Welcome to Coastal Defense!", [
                { text: 'Start Game', action: startGame } // Button with Label AND action!
            ]);
        };


    </script>
</body>
</html>
